<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sistema de Campeonato (Firestore)</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-6">Sistema de Campeonato ğŸ†</h1>

        <div class="flex flex-wrap justify-center gap-2 mb-6">
            <button id="inscricaoBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg">ğŸ“ InscriÃ§Ãµes</button>
            <button id="publicoBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg">ğŸ‘¥ Lista PÃºblica</button>
            <button id="acompanharBtn" class="bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded-lg">ğŸ“Š Acompanhar</button>
            <button id="adminBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg">âš™ï¸ Admin</button>
        </div>

        <!-- SeÃ§Ãµes (inscriÃ§Ã£o, lista, acompanhar, admin) -->
        <!-- ... (tudo igual ao seu cÃ³digo anterior atÃ© a parte do script) ... -->

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import { getFirestore, collection, doc, addDoc, getDocs, deleteDoc, setDoc, updateDoc, getDoc, query, where, writeBatch } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBo8G3ZcWk4EepN0cHdVBtXc7tGOfcw-yg",
            authDomain: "inscricaosinuca.firebaseapp.com",
            projectId: "inscricaosinuca",
            storageBucket: "inscricaosinuca.firebasestorage.app",
            messagingSenderId: "338241576305",
            appId: "1:338241576305:web:288b6124384c6be4f76ad0",
            measurementId: "G-PEDG30FS2R"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const inscritosCol = collection(db, "inscritos");
        const modalidadesCol = collection(db, "modalidades");
        const fasesCol = collection(db, "fases");
        const jogosCol = collection(db, "jogos");
        const configDocRef = doc(db, "config", "geral");

        // ... (todo o restante do cÃ³digo continua igual atÃ© o trecho de criar fases) ...

        /* ---------- ADMIN: CRIAR FASES (alterado para duplas) ---------- */
        document.getElementById('criarFaseBtn').addEventListener('click', async () => {
            const modalidade = document.getElementById('faseModalidade').value;
            if (!modalidade) return alert('Selecione uma modalidade para criar a fase.');

            const fasesSnap = await getDocs(query(fasesCol, where("modalidade", "==", modalidade)));
            const numero = fasesSnap.size + 1;
            let players = [];

            if (numero === 1) {
                const q = query(inscritosCol, where("modalidades", "array-contains", modalidade));
                const inscritosSnap = await getDocs(q);
                players = inscritosSnap.docs.map(d => ({ id: d.id, nome: d.data().nome }));
            } else {
                const faseAnterior = numero - 1;
                const jogosSnap = await getDocs(query(jogosCol, where("modalidade", "==", modalidade), where("fase", "==", faseAnterior)));
                if (jogosSnap.empty) return alert('NÃ£o hÃ¡ jogos na fase anterior para gerar a prÃ³xima.');

                let vencedores = [];
                let perdedores = [];

                for (const docu of jogosSnap.docs) {
                    const j = docu.data();
                    const partidaFinalizada = (j.placar1 >= 2 || j.placar2 >= 2);
                    if (!partidaFinalizada) {
                        return alert('Todos os jogos da fase anterior precisam estar finalizados.');
                    }
                    if (j.placar1 > j.placar2) {
                        vencedores.push(j.dupla1);
                        perdedores.push(j.dupla2);
                    } else {
                        vencedores.push(j.dupla2);
                        perdedores.push(j.dupla1);
                    }
                }

                // "achatando" vencedores (que jÃ¡ sÃ£o duplas)
                players = vencedores.flatMap(d => d.split(" + ").map(nome => ({ nome })));
            }

            if (players.length < 4) return alert('NÃ£o hÃ¡ jogadores suficientes para criar duplas.');

            // embaralha lista
            players.sort(() => Math.random() - 0.5);

            // formar duplas
            let duplas = [];
            for (let i = 0; i < players.length; i += 2) {
                if (!players[i + 1]) {
                    alert(`O jogador ${players[i].nome} ficou sem dupla e foi descartado.`);
                    continue;
                }
                duplas.push(players[i].nome + " + " + players[i + 1].nome);
            }

            if (duplas.length < 2) return alert('NÃ£o hÃ¡ duplas suficientes para criar jogos.');

            // embaralha duplas
            duplas.sort(() => Math.random() - 0.5);

            const batch = writeBatch(db);
            for (let i = 0; i < duplas.length; i += 2) {
                if (!duplas[i + 1]) continue;
                const jogoRef = doc(collection(db, "jogos"));
                batch.set(jogoRef, {
                    modalidade,
                    fase: numero,
                    dupla1: duplas[i],
                    dupla2: duplas[i + 1],
                    placar1: 0,
                    placar2: 0,
                    finalizado: false
                });
            }
            await batch.commit();
            await addDoc(fasesCol, { modalidade, numero, players: players.map(p => p.nome) });
            alert(`Fase ${numero} para ${modalidade} criada com confrontos de duplas!`);
            carregarFasesAdmin();
        });

        // ... (restante do cÃ³digo continua igual) ...

    </script>
</body>
</html>
